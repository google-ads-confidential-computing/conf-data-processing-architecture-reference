From e40746b43cdf03397e5f43eca81b1e3eacb46c75 Mon Sep 17 00:00:00 2001
From: George Chih <georgechih@google.com>
Date: Fri, 17 Oct 2025 17:02:48 +0000
Subject: [PATCH 1/2] Override grpc library source code to make it return
 useful error message if the error is not due to network connection.

By default, if the OAuth token is failed to parse within grpc server-client connections, grpc library always returns UNAVAILABLE with no additional error mesage. We make this patch file to align with https://github.com/grpc/grpc/pull/40907.

This can help the developer easier to troubleshooting the error code from the KMS client, which the KMS server frequently returns error in our production traffic.
---
 src/core/BUILD                                |   2 +
 ...cp_service_account_identity_credentials.cc | 160 +++++++-----------
 ...gcp_service_account_identity_credentials.h |  12 +-
 .../credentials/oauth2/oauth2_credentials.cc  |  77 +++------
 .../credentials/oauth2/oauth2_credentials.h   |   8 +-
 .../token_fetcher_credentials.cc              |  42 +++++
 .../token_fetcher/token_fetcher_credentials.h |  29 ++++
 test/core/security/credentials_test.cc        |  23 ++-
 8 files changed, 173 insertions(+), 180 deletions(-)

diff --git a/src/core/BUILD b/src/core/BUILD
index f65a41fbe3..268e5ed6f1 100644
--- a/src/core/BUILD
+++ b/src/core/BUILD
@@ -4489,0 +4490 @@ grpc_cc_library(
+        "status_conversion",
@@ -4587,0 +4589 @@ grpc_cc_library(
+        "status_conversion",
diff --git a/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.cc b/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.cc
index 31d00e7bfd..27617d5658 100644
--- a/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.cc
+++ b/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.cc
@@ -28,0 +29 @@
+#include "src/core/lib/security/credentials/token_fetcher/token_fetcher_credentials.h"
@@ -45,27 +46,2 @@ namespace grpc_core {
-// State held for a pending HTTP request.
-class JwtTokenFetcherCallCredentials::HttpFetchRequest final
-    : public TokenFetcherCredentials::FetchRequest {
- public:
-  HttpFetchRequest(
-      JwtTokenFetcherCallCredentials* creds, Timestamp deadline,
-      absl::AnyInvocable<
-          void(absl::StatusOr<RefCountedPtr<TokenFetcherCredentials::Token>>)>
-          on_done)
-      : on_done_(std::move(on_done)) {
-    GRPC_CLOSURE_INIT(&on_http_response_, OnHttpResponse, this, nullptr);
-    Ref().release();  // Ref held by HTTP request callback.
-    http_request_ = creds->StartHttpRequest(creds->pollent(), deadline,
-                                            &response_, &on_http_response_);
-  }
-
-  ~HttpFetchRequest() override { grpc_http_response_destroy(&response_); }
-
-  void Orphan() override {
-    http_request_.reset();
-    Unref();
-  }
-
- private:
-  static void OnHttpResponse(void* arg, grpc_error_handle error) {
-    RefCountedPtr<HttpFetchRequest> self(static_cast<HttpFetchRequest*>(arg));
-    if (!error.ok()) {
+OrphanablePtr<TokenFetcherCredentials::FetchRequest>
+JwtTokenFetcherCallCredentials::FetchToken(
@@ -76,72 +52 @@ class JwtTokenFetcherCallCredentials::HttpFetchRequest final
-      self->on_done_(absl::UnavailableError(StatusToString(error)));
-      return;
-    }
-    if (self->response_.status != 200) {
-      grpc_status_code status_code =
-          grpc_http2_status_to_grpc_status(self->response_.status);
-      if (status_code != GRPC_STATUS_UNAVAILABLE) {
-        status_code = GRPC_STATUS_UNAUTHENTICATED;
-      }
-      self->on_done_(absl::Status(static_cast<absl::StatusCode>(status_code),
-                                  absl::StrCat("JWT fetch failed with status ",
-                                               self->response_.status)));
-      return;
-    }
-    absl::string_view body(self->response_.body, self->response_.body_length);
-    // Parse JWT token based on https://datatracker.ietf.org/doc/html/rfc7519.
-    // We don't do full verification here, just enough to extract the
-    // expiration time.
-    // First, split the 3 '.'-delimited parts.
-    std::vector<absl::string_view> parts = absl::StrSplit(body, '.');
-    if (parts.size() != 3) {
-      self->on_done_(absl::UnauthenticatedError("error parsing JWT token"));
-      return;
-    }
-    // Base64-decode the payload.
-    std::string payload;
-    if (!absl::WebSafeBase64Unescape(parts[1], &payload)) {
-      self->on_done_(absl::UnauthenticatedError("error parsing JWT token"));
-      return;
-    }
-    // Parse as JSON.
-    auto json = JsonParse(payload);
-    if (!json.ok()) {
-      self->on_done_(absl::UnauthenticatedError("error parsing JWT token"));
-      return;
-    }
-    // Extract "exp" field.
-    struct ParsedPayload {
-      uint64_t exp = 0;
-
-      static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {
-        static const auto kJsonLoader = JsonObjectLoader<ParsedPayload>()
-                                            .Field("exp", &ParsedPayload::exp)
-                                            .Finish();
-        return kJsonLoader;
-      }
-    };
-    auto parsed_payload = LoadFromJson<ParsedPayload>(*json, JsonArgs(), "");
-    if (!parsed_payload.ok()) {
-      self->on_done_(absl::UnauthenticatedError("error parsing JWT token"));
-      return;
-    }
-    gpr_timespec ts = gpr_time_0(GPR_CLOCK_REALTIME);
-    ts.tv_sec = parsed_payload->exp;
-    Timestamp expiration_time = Timestamp::FromTimespecRoundDown(ts);
-    // Return token object.
-    self->on_done_(MakeRefCounted<Token>(
-        Slice::FromCopiedString(absl::StrCat("Bearer ", body)),
-        expiration_time));
-  }
-
-  OrphanablePtr<HttpRequest> http_request_;
-  grpc_closure on_http_response_;
-  grpc_http_response response_;
-  absl::AnyInvocable<void(
-      absl::StatusOr<RefCountedPtr<TokenFetcherCredentials::Token>>)>
-      on_done_;
-};
-
-OrphanablePtr<TokenFetcherCredentials::FetchRequest>
-JwtTokenFetcherCallCredentials::FetchToken(
-    Timestamp deadline,
+  Timestamp deadline,
@@ -151 +56,56 @@ JwtTokenFetcherCallCredentials::FetchToken(
-  return MakeOrphanable<HttpFetchRequest>(this, deadline, std::move(on_done));
+  return MakeOrphanable<HttpTokenFetcherCredentials::HttpFetchRequest>(
+      this, deadline,
+      [on_done = std::move(on_done)](
+          absl::StatusOr<grpc_http_response> response) mutable {
+        if (!response.ok()) {
+          on_done(response.status());
+          return;
+        }
+        absl::string_view body(response->body, response->body_length);
+        // Parse JWT token based on
+        // https://datatracker.ietf.org/doc/html/rfc7519. We don't do full
+        // verification here, just enough to extract the expiration time. First,
+        // split the 3 '.'-delimited parts.
+        std::vector<absl::string_view> parts = absl::StrSplit(body, '.');
+        if (parts.size() != 3) {
+          on_done(absl::UnauthenticatedError("error parsing JWT token"));
+          return;
+        }
+        // Base64-decode the payload.
+        std::string payload;
+        if (!absl::WebSafeBase64Unescape(parts[1], &payload)) {
+          on_done(absl::UnauthenticatedError("error parsing JWT token"));
+          return;
+        }
+        // Parse as JSON.
+        auto json = JsonParse(payload);
+        if (!json.ok()) {
+          on_done(absl::UnauthenticatedError("error parsing JWT token"));
+          return;
+        }
+        // Extract "exp" field.
+        struct ParsedPayload {
+          uint64_t exp = 0;
+
+          static const JsonLoaderInterface* JsonLoader(const JsonArgs&) {
+            static const auto kJsonLoader =
+                JsonObjectLoader<ParsedPayload>()
+                    .Field("exp", &ParsedPayload::exp)
+                    .Finish();
+            return kJsonLoader;
+          }
+        };
+        auto parsed_payload =
+            LoadFromJson<ParsedPayload>(*json, JsonArgs(), "");
+        if (!parsed_payload.ok()) {
+          on_done(absl::UnauthenticatedError("error parsing JWT token"));
+          return;
+        }
+        gpr_timespec ts = gpr_time_0(GPR_CLOCK_REALTIME);
+        ts.tv_sec = parsed_payload->exp;
+        Timestamp expiration_time = Timestamp::FromTimespecRoundDown(ts);
+        // Return token object.
+        on_done(MakeRefCounted<Token>(
+            Slice::FromCopiedString(absl::StrCat("Bearer ", body)),
+            expiration_time));
+      });
diff --git a/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.h b/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.h
index 7e3dfaa2ab..68151fd81c 100644
--- a/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.h
+++ b/src/core/lib/security/credentials/gcp_service_account_identity/gcp_service_account_identity_credentials.h
@@ -43 +43 @@ namespace grpc_core {
-class JwtTokenFetcherCallCredentials : public TokenFetcherCredentials {
+class JwtTokenFetcherCallCredentials : public HttpTokenFetcherCredentials {
@@ -47,2 +47 @@ class JwtTokenFetcherCallCredentials : public TokenFetcherCredentials {
-      absl::AnyInvocable<
-          void(absl::StatusOr<RefCountedPtr<TokenFetcherCredentials::Token>>)>
+      absl::AnyInvocable<void(absl::StatusOr<RefCountedPtr<TokenFetcherCredentials::Token>>)>
@@ -50,7 +48,0 @@ class JwtTokenFetcherCallCredentials : public TokenFetcherCredentials {
-
- private:
-  class HttpFetchRequest;
-
-  virtual OrphanablePtr<HttpRequest> StartHttpRequest(
-      grpc_polling_entity* pollent, Timestamp deadline,
-      grpc_http_response* response, grpc_closure* on_complete) = 0;
diff --git a/src/core/lib/security/credentials/oauth2/oauth2_credentials.cc b/src/core/lib/security/credentials/oauth2/oauth2_credentials.cc
index 0e7f7eb33c..5fadc42d5a 100644
--- a/src/core/lib/security/credentials/oauth2/oauth2_credentials.cc
+++ b/src/core/lib/security/credentials/oauth2/oauth2_credentials.cc
@@ -24,0 +25 @@
+#include <grpc/status.h>
@@ -54,0 +56 @@
+#include "src/core/lib/transport/status_conversion.h"
@@ -212,53 +213,0 @@ namespace grpc_core {
-
-// State held for a pending HTTP request.
-class Oauth2TokenFetcherCredentials::HttpFetchRequest final
-    : public TokenFetcherCredentials::FetchRequest {
- public:
-  HttpFetchRequest(
-      Oauth2TokenFetcherCredentials* creds, Timestamp deadline,
-      absl::AnyInvocable<
-          void(absl::StatusOr<RefCountedPtr<TokenFetcherCredentials::Token>>)>
-          on_done)
-      : on_done_(std::move(on_done)) {
-    GRPC_CLOSURE_INIT(&on_http_response_, OnHttpResponse, this, nullptr);
-    Ref().release();  // Ref held by HTTP request callback.
-    http_request_ = creds->StartHttpRequest(creds->pollent(), deadline,
-                                            &response_, &on_http_response_);
-  }
-
-  ~HttpFetchRequest() override { grpc_http_response_destroy(&response_); }
-
-  void Orphan() override {
-    http_request_.reset();
-    Unref();
-  }
-
- private:
-  static void OnHttpResponse(void* arg, grpc_error_handle error) {
-    RefCountedPtr<HttpFetchRequest> self(static_cast<HttpFetchRequest*>(arg));
-    if (!error.ok()) {
-      self->on_done_(std::move(error));
-      return;
-    }
-    // Parse oauth2 token.
-    absl::optional<Slice> access_token_value;
-    Duration token_lifetime;
-    grpc_credentials_status status =
-        grpc_oauth2_token_fetcher_credentials_parse_server_response(
-            &self->response_, &access_token_value, &token_lifetime);
-    if (status != GRPC_CREDENTIALS_OK) {
-      self->on_done_(absl::UnavailableError("error parsing oauth2 token"));
-      return;
-    }
-    self->on_done_(MakeRefCounted<Token>(std::move(*access_token_value),
-                                         Timestamp::Now() + token_lifetime));
-  }
-
-  OrphanablePtr<HttpRequest> http_request_;
-  grpc_closure on_http_response_;
-  grpc_http_response response_;
-  absl::AnyInvocable<void(
-      absl::StatusOr<RefCountedPtr<TokenFetcherCredentials::Token>>)>
-      on_done_;
-};
-
@@ -280 +229,21 @@ Oauth2TokenFetcherCredentials::FetchToken(
-  return MakeOrphanable<HttpFetchRequest>(this, deadline, std::move(on_done));
+  return MakeOrphanable<HttpTokenFetcherCredentials::HttpFetchRequest>(
+      this, deadline,
+      [on_done = std::move(on_done)](
+          absl::StatusOr<grpc_http_response> response) mutable {
+        if (!response.ok()) {
+          on_done(response.status());
+          return;
+        }
+        // Parse oauth2 token.
+        absl::optional<Slice> access_token_value;
+        Duration token_lifetime;
+        grpc_credentials_status status =
+            grpc_oauth2_token_fetcher_credentials_parse_server_response(
+                &(*response), &access_token_value, &token_lifetime);
+        if (status != GRPC_CREDENTIALS_OK) {
+          on_done(absl::UnavailableError("error parsing oauth2 token"));
+          return;
+        }
+        on_done(MakeRefCounted<Token>(std::move(*access_token_value),
+                                      Timestamp::Now() + token_lifetime));
+      });
diff --git a/src/core/lib/security/credentials/oauth2/oauth2_credentials.h b/src/core/lib/security/credentials/oauth2/oauth2_credentials.h
index 5cba69234d..863f356f94 100644
--- a/src/core/lib/security/credentials/oauth2/oauth2_credentials.h
+++ b/src/core/lib/security/credentials/oauth2/oauth2_credentials.h
@@ -93 +93 @@ namespace grpc_core {
-class Oauth2TokenFetcherCredentials : public TokenFetcherCredentials {
+class Oauth2TokenFetcherCredentials : public HttpTokenFetcherCredentials {
@@ -105,4 +104,0 @@ class Oauth2TokenFetcherCredentials : public TokenFetcherCredentials {
-  virtual OrphanablePtr<HttpRequest> StartHttpRequest(
-      grpc_polling_entity* pollent, Timestamp deadline,
-      grpc_http_response* response, grpc_closure* on_complete) = 0;
-
@@ -110,2 +105,0 @@ class Oauth2TokenFetcherCredentials : public TokenFetcherCredentials {
-  class HttpFetchRequest;
-
diff --git a/src/core/lib/security/credentials/token_fetcher/token_fetcher_credentials.cc b/src/core/lib/security/credentials/token_fetcher/token_fetcher_credentials.cc
index 66fb470c3f..f0b9c6f668 100644
--- a/src/core/lib/security/credentials/token_fetcher/token_fetcher_credentials.cc
+++ b/src/core/lib/security/credentials/token_fetcher/token_fetcher_credentials.cc
@@ -26,0 +27 @@
+#include "src/core/lib/transport/status_conversion.h"
@@ -304,0 +306,41 @@ TokenFetcherCredentials::GetRequestMetadata(
+//
+// HttpTokenFetcherCredentials
+//
+
+HttpTokenFetcherCredentials::HttpFetchRequest::HttpFetchRequest(
+    HttpTokenFetcherCredentials* creds, Timestamp deadline,
+    absl::AnyInvocable<void(absl::StatusOr<grpc_http_response>)> on_done)
+    : on_done_(std::move(on_done)) {
+  GRPC_CLOSURE_INIT(&on_http_response_, OnHttpResponse, this, nullptr);
+  Ref().release();  // Ref held by HTTP request callback.
+  http_request_ = creds->StartHttpRequest(creds->pollent(), deadline,
+                                          &response_, &on_http_response_);
+}
+
+void HttpTokenFetcherCredentials::HttpFetchRequest::Orphan() {
+  http_request_.reset();
+  Unref();
+}
+
+void HttpTokenFetcherCredentials::HttpFetchRequest::OnHttpResponse(
+    void* arg, grpc_error_handle error) {
+  RefCountedPtr<HttpFetchRequest> self(static_cast<HttpFetchRequest*>(arg));
+  if (!error.ok()) {
+    self->on_done_(absl::UnavailableError(StatusToString(error)));
+    return;
+  }
+  if (self->response_.status != 200) {
+    grpc_status_code status_code =
+        grpc_http2_status_to_grpc_status(self->response_.status);
+    if (status_code != GRPC_STATUS_UNAVAILABLE) {
+      status_code = GRPC_STATUS_UNAUTHENTICATED;
+    }
+    self->on_done_(
+        absl::Status(static_cast<absl::StatusCode>(status_code),
+                     absl::StrCat("HTTP token fetch failed with status ",
+                                  self->response_.status)));
+    return;
+  }
+  self->on_done_(self->response_);
+}
+
diff --git a/src/core/lib/security/credentials/token_fetcher/token_fetcher_credentials.h b/src/core/lib/security/credentials/token_fetcher/token_fetcher_credentials.h
index 9f0afc1a91..f34e66e2a4 100644
--- a/src/core/lib/security/credentials/token_fetcher/token_fetcher_credentials.h
+++ b/src/core/lib/security/credentials/token_fetcher/token_fetcher_credentials.h
@@ -178,0 +179,29 @@ class TokenFetcherCredentials : public grpc_call_credentials {
+// A base class for fetching tokens via an HTTP request.
+class HttpTokenFetcherCredentials : public TokenFetcherCredentials {
+ public:
+  virtual OrphanablePtr<HttpRequest> StartHttpRequest(grpc_polling_entity* pollent,
+                                                      Timestamp deadline,
+                                                      grpc_http_response* response,
+                                                      grpc_closure* on_complete) = 0;
+
+ protected:
+  // State held for a pending HTTP request.
+  class HttpFetchRequest : public TokenFetcherCredentials::FetchRequest {
+   public:
+    // The given callback should assume the http response status has already
+    // been checked and handle the token parsing.
+    HttpFetchRequest(HttpTokenFetcherCredentials* creds, Timestamp deadline,
+                     absl::AnyInvocable<void(absl::StatusOr<grpc_http_response>)> on_done);
+    ~HttpFetchRequest() override { grpc_http_response_destroy(&response_); }
+
+    void Orphan() override;
+
+   private:
+    static void OnHttpResponse(void* arg, grpc_error_handle error);
+    OrphanablePtr<HttpRequest> http_request_;
+    grpc_closure on_http_response_;
+    grpc_http_response response_;
+    absl::AnyInvocable<void(absl::StatusOr<grpc_http_response>)> on_done_;
+  };
+};
+
diff --git a/test/core/security/credentials_test.cc b/test/core/security/credentials_test.cc
index d70fd4cb96..91c2cadaf5 100644
--- a/test/core/security/credentials_test.cc
+++ b/test/core/security/credentials_test.cc
@@ -813 +813,2 @@ TEST_F(CredentialsTest, TestComputeEngineCredsFailure) {
-      absl::UnavailableError("error parsing oauth2 token"), {});
+      absl::UnauthenticatedError("HTTP token fetch failed with status 403"),
+      {});
@@ -906 +907,2 @@ TEST_F(CredentialsTest, TestRefreshTokenCredsFailure) {
-      absl::UnavailableError("error parsing oauth2 token"), {});
+      absl::UnauthenticatedError("HTTP token fetch failed with status 403"),
+      {});
@@ -1167,2 +1169,2 @@ TEST_F(CredentialsTest, TestStsCredsTokenFileNotFound) {
-      absl::InternalError(
-          "Failed to load file: /some/completely/random/path due to "
+      absl::UnavailableError(
+          "INTERNAL:Failed to load file: /some/completely/random/path due to "
@@ -1239,2 +1241,3 @@ TEST_F(CredentialsTest, TestStsCredsLoadTokenFailure) {
-      absl::InternalError("Failed to load file: invalid_path due to "
-                          "error(fdopen): No such file or directory"),
+      absl::UnavailableError(
+          "INTERNAL:Failed to load file: invalid_path due to "
+          "error(fdopen): No such file or directory"),
@@ -1275 +1278,2 @@ TEST_F(CredentialsTest, TestStsCredsHttpFailure) {
-      absl::UnavailableError("error parsing oauth2 token"), {});
+      absl::UnauthenticatedError("HTTP token fetch failed with status 403"),
+      {});
@@ -4573 +4577 @@ TEST_F(GcpServiceAccountIdentityCredentialsTest, FailsWithHttpStatus429) {
-      absl::UnavailableError("JWT fetch failed with status 429"), "");
+      absl::UnavailableError("HTTP token fetch failed with status 429"), "");
@@ -4590 +4594,2 @@ TEST_F(GcpServiceAccountIdentityCredentialsTest, FailsWithHttpStatus400) {
-      absl::UnauthenticatedError("JWT fetch failed with status 400"), "");
+      absl::UnauthenticatedError("HTTP token fetch failed with status 400"),
+      "");
--
2.52.0.457.g6b5491de43-goog


From a1bcaefd5a55c228f01224e330f9aade36a8d4f7 Mon Sep 17 00:00:00 2001
From: George Chih <georgechih@google.com>
Date: Tue, 13 Jan 2026 06:41:50 +0000
Subject: [PATCH 2/2] Improve the error status returned from external account
 credentials

---
 src/core/BUILD                                |  1 +
 .../aws_external_account_credentials.cc       |  4 +-
 .../external/external_account_credentials.cc  | 15 +++--
 .../file_external_account_credentials.cc      |  4 +-
 test/core/security/credentials_test.cc        | 64 +++++++++++++++++--
 5 files changed, 74 insertions(+), 14 deletions(-)

diff --git a/src/core/BUILD b/src/core/BUILD
index 268e5ed6f1..1b5081dfd3 100644
--- a/src/core/BUILD
+++ b/src/core/BUILD
@@ -4650,0 +4651 @@ grpc_cc_library(
+        "status_conversion",
diff --git a/src/core/lib/security/credentials/external/aws_external_account_credentials.cc b/src/core/lib/security/credentials/external/aws_external_account_credentials.cc
index 13a46dadda..b31813c8ce 100644
--- a/src/core/lib/security/credentials/external/aws_external_account_credentials.cc
+++ b/src/core/lib/security/credentials/external/aws_external_account_credentials.cc
@@ -296,2 +296,2 @@ void AwsExternalAccountCredentials::AwsFetchBody::RetrieveSigningKeys() {
-    AsyncFinish(
-        GRPC_ERROR_CREATE("Missing role name when retrieving signing keys."));
+    AsyncFinish(absl::UnauthenticatedError(
+        "Missing role name when retrieving signing keys."));
diff --git a/src/core/lib/security/credentials/external/external_account_credentials.cc b/src/core/lib/security/credentials/external/external_account_credentials.cc
index d8bacf7299..a1901e0a98 100644
--- a/src/core/lib/security/credentials/external/external_account_credentials.cc
+++ b/src/core/lib/security/credentials/external/external_account_credentials.cc
@@ -50,0 +51 @@
+#include "src/core/lib/transport/status_conversion.h"
@@ -112 +113,7 @@ void ExternalAccountCredentials::HttpFetchBody::OnHttpResponse(
-    self->Finish(absl::UnavailableError(
+    grpc_status_code status_code =
+        grpc_http2_status_to_grpc_status(self->response_.status);
+    if (status_code != GRPC_STATUS_UNAVAILABLE) {
+      status_code = GRPC_STATUS_UNAUTHENTICATED;
+    }
+    self->Finish(absl::Status(
+        static_cast<absl::StatusCode>(status_code),
@@ -184 +191 @@ void ExternalAccountCredentials::ExternalFetchRequest::ExchangeToken(
-    return FinishTokenFetch(GRPC_ERROR_CREATE(
+    return FinishTokenFetch(absl::UnauthenticatedError(
@@ -288 +295 @@ void ExternalAccountCredentials::ExternalFetchRequest::
-    FinishTokenFetch(GRPC_ERROR_CREATE(absl::StrFormat(
+    FinishTokenFetch(absl::UnauthenticatedError(absl::StrFormat(
@@ -296 +303 @@ void ExternalAccountCredentials::ExternalFetchRequest::
-    FinishTokenFetch(GRPC_ERROR_CREATE(absl::StrFormat(
+    FinishTokenFetch(absl::UnauthenticatedError(absl::StrFormat(
diff --git a/src/core/lib/security/credentials/external/file_external_account_credentials.cc b/src/core/lib/security/credentials/external/file_external_account_credentials.cc
index a02fb698c3..1ece4e0cd5 100644
--- a/src/core/lib/security/credentials/external/file_external_account_credentials.cc
+++ b/src/core/lib/security/credentials/external/file_external_account_credentials.cc
@@ -59 +59 @@ void FileExternalAccountCredentials::FileFetchBody::ReadFile() {
-    Finish(content_slice.status());
+    Finish(absl::UnavailableError(content_slice.status().message()));
@@ -66 +66 @@ void FileExternalAccountCredentials::FileFetchBody::ReadFile() {
-      Finish(GRPC_ERROR_CREATE(
+      Finish(absl::UnauthenticatedError(
diff --git a/test/core/security/credentials_test.cc b/test/core/security/credentials_test.cc
index 91c2cadaf5..97e12c6a0c 100644
--- a/test/core/security/credentials_test.cc
+++ b/test/core/security/credentials_test.cc
@@ -2273,0 +2274,15 @@ int external_account_creds_httpcli_post_failure_token_exchange_response_missing_
+int external_account_creds_httpcli_post_failure_token_exchange_bad_request(
+    const grpc_http_request* /*request*/, const URI& uri,
+    absl::string_view /*body*/, Timestamp /*deadline*/, grpc_closure* on_done,
+    grpc_http_response* response) {
+  if (uri.path() == "/token") {
+    *response = http_response(400, "");
+  } else if (uri.path() == "/service_account_impersonation") {
+    *response = http_response(
+        200,
+        valid_external_account_creds_service_account_impersonation_response);
+  }
+  ExecCtx::Run(DEBUG_LOCATION, on_done, absl::OkStatus());
+  return 1;
+}
+
@@ -3070 +3085 @@ TEST_F(ExternalAccountCredentialsTest, FailureInvalidTokenUrl) {
-  grpc_error_handle expected_error = absl::UnknownError(
+  grpc_error_handle expected_error = absl::UnauthenticatedError(
@@ -3109 +3124 @@ TEST_F(ExternalAccountCredentialsTest,
-  grpc_error_handle expected_error = absl::UnknownError(
+  grpc_error_handle expected_error = absl::UnauthenticatedError(
@@ -3150 +3165 @@ TEST_F(ExternalAccountCredentialsTest,
-  grpc_error_handle expected_error = absl::UnknownError(
+  grpc_error_handle expected_error = absl::UnauthenticatedError(
@@ -3161,0 +3177,37 @@ TEST_F(ExternalAccountCredentialsTest,
+TEST_F(ExternalAccountCredentialsTest, FailureTokenExchangeResponseNotOk) {
+  ExecCtx exec_ctx;
+  Json credential_source = Json::FromString("");
+  TestExternalAccountCredentials::ServiceAccountImpersonation
+      service_account_impersonation;
+  service_account_impersonation.token_lifetime_seconds = 3600;
+  TestExternalAccountCredentials::Options options = {
+      "external_account",    // type;
+      "audience",            // audience;
+      "subject_token_type",  // subject_token_type;
+      "https://foo.com:5555/service_account_impersonation",  // service_account_impersonation_url;
+      service_account_impersonation,      // service_account_impersonation;
+      "https://foo.com:5555/token",       // token_url;
+      "https://foo.com:5555/token_info",  // token_info_url;
+      credential_source,                  // credential_source
+      "quota_project_id",                 // quota_project_id;
+      "client_id",                        // client_id;
+      "client_secret",                    // client_secret;
+      "",                                 // workforce_pool_user_project;
+  };
+  auto creds = MakeRefCounted<TestExternalAccountCredentials>(
+      options, std::vector<std::string>(), event_engine_);
+  HttpRequest::SetOverride(
+      httpcli_get_should_not_be_called,
+      external_account_creds_httpcli_post_failure_token_exchange_bad_request,
+      httpcli_put_should_not_be_called);
+  grpc_error_handle expected_error = absl::UnauthenticatedError(
+      "error fetching oauth2 token: Call to HTTP server ended with status 400 "
+      "[]");
+  auto state = RequestMetadataState::NewInstance(expected_error, {});
+  state->RunRequestMetadataTest(creds.get(), kTestUrlScheme, kTestAuthority,
+                                kTestPath);
+  ExecCtx::Get()->Flush();
+  event_engine_->TickUntilIdle();
+  HttpRequest::SetOverride(nullptr, nullptr, nullptr);
+}
+
@@ -3439 +3491 @@ TEST_F(ExternalAccountCredentialsTest,
-  grpc_error_handle expected_error = absl::InternalError(
+  grpc_error_handle expected_error = absl::UnavailableError(
@@ -3490 +3542 @@ TEST_F(ExternalAccountCredentialsTest,
-  grpc_error_handle expected_error = absl::UnknownError(
+  grpc_error_handle expected_error = absl::UnauthenticatedError(
@@ -4199 +4251 @@ TEST_F(ExternalAccountCredentialsTest,
-  grpc_error_handle expected_error = absl::UnknownError(
+  grpc_error_handle expected_error = absl::UnauthenticatedError(
--
2.52.0.457.g6b5491de43-goog

